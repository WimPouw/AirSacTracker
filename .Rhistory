install.packages("install.load")
}
library(install.load)
install_load("tidyverse")
# 01: functionality ----
## 01a : sub-function circle_format ----
# sub-function to transform already pre-processed datasheet into format
# necessary for circle estimation, which needs x and y for all points in two
# columns, 1 point combination per row
circle_format <- function(df_sub){
df_all <- data.frame()
df <- data.frame(matrix(ncol = 4, nrow = 0))
x <- c("x", "y", "likelihood", "frame")
colnames(df) <- x
for (frame in 1:nrow(df_sub)){
for (b in 1:5){
end_col <- b*3
start_col <- end_col - 2
df[b, 1:3] <-  df_sub[frame, start_col:end_col]
df[b, 4] <- frame
}
df_all <- rbind(df_all, df)
}
return(df_all)
}
## 01b: main ----
# list of columns needed for circle estimation used later in function
list_airsac_points <- c('Start_outline_outer_left_x','Start_outline_outer_left_y', 'Start_outline_outer_left_likelihood',
'Start_outline_outer_right_x', 'Start_outline_outer_right_y', 'Start_outline_outer_right_likelihood',
'LowestPoint_outline_x', 'LowestPoint_outline_y', 'LowestPoint_outline_likelihood',
'MidLowleft_outline_x', 'MidLowleft_outline_y', 'MidLowleft_outline_likelihood',
'MidLowright_outline_x', 'MidLowright_outline_y', 'MidLowright_outline_likelihood')
colnames <- c()
colnames[1] <- "frames"
for (x in 2: ncol(data)){
colnames[x] <- paste(data[1,x],data[2,x], sep = '_')
}
colnames(data) <- colnames
df_all <- data[-1:-2,]
df_sub <- df_all %>%
select(all_of(list_airsac_points))
df_sub <- as.data.frame(apply(df_sub,2,as.numeric))
circle_format_data <- circle_format(df_sub)
return(circle_format_data)
}
nose_eye_normalization <- function(auto_data, a = a,  min_frames = 2, threshold_normalization = 0.8){
norm_data <- c()
list_normalization_points <- c('Nose_x','Nose_y', 'Nose_likelihood',
'EyeBridge_x', 'EyeBridge_y', 'EyeBridge_likelihood')
colnames <- c()
colnames[1] <- "frames"
for (x in 2: ncol(auto_data)){
colnames[x] <- paste(auto_data[1,x],auto_data[2,x], sep = '_')
}
colnames(auto_data) <- colnames
df <- auto_data[-1:-2,]
df_sub <- df %>%
select(all_of(list_normalization_points))
df_sub <- as.data.frame(apply(df_sub,2,as.numeric))
euc_dist <- function(xbridge, xnose, ybridge, ynose){
return(sqrt(((xbridge-xnose)^2+((ybridge-ynose)^2))))
}
df_sub_normalization <- df_sub %>%
dplyr::filter(Nose_likelihood >= threshold_normalization &&
EyeBridge_likelihood >= threshold_normalization)
if(nrow(df_sub_normalization) >= min_frames){
distance <- foreach::foreach(i= 1:nrow(df_sub_normalization), .combine = c) %do%
euc_dist(df_sub_normalization$EyeBridge_x, df_sub_normalization$Nose_x,
df_sub_normalization$EyeBridge_y, df_sub_normalization$Nose_y)
} else {
distance <- NA
}
norm_data <- mean(distance, na.rm = TRUE)
return(norm_data)
}
from_DLC_to_circle <- function(path, list_of_files){
radius_all <- data.frame(matrix(ncol = 5, nrow = 0))
z <- c("radius","x","y", "frame", "videofile")
colnames(radius_all) <- z
normalization_value <- data.frame(matrix(ncol = 2, nrow = length(list_of_files)))
y <- c("normalization_value", "videofile")
colnames(normalization_value) <- y
## starting main loop ----
for (a in 1:length(list_of_files)) {
radius <- data.frame()
auto_data <- read_delim(paste(path, list_of_files[a], sep = "\\"), delim = "," )
# 02: pre-processing data ----
data_circle_estimation <- data_prep_radius_estim_DLC(data = auto_data)
grouped_data_circle_estimation <- data_circle_estimation %>%
dplyr::filter(likelihood > threshold) %>%
group_split(frame)
for(n in 1:length(grouped_data_circle_estimation)){
if (length(grouped_data_circle_estimation) > 0){
frame_data <- as.data.frame(grouped_data_circle_estimation[[n]])
if(nrow(frame_data)>=3){
circles_LAN <- CircleFitByLandau(frame_data[,1:2], ParIni = NA, epsilon = 1e-06, IterMAX = 500)
}else {
circles_LAN <- c(NA, NA, NA, NA, NA)
}
circles_res <- c(circles_LAN[3],circles_LAN[1], circles_LAN[2], n, list_of_files[a])
radius <- rbind(radius, circles_res)
colnames(radius) <- z
} else {circles_LAN <- c(NA, NA, NA, NA, NA)
circles_res <- c(circles_LAN[3],circles_LAN[1], circles_LAN[2], n, list_of_files[a])
radius <- rbind(radius, circles_res)
colnames(radius) <- z}
}
print(a)
radius_all <- rbind(radius_all, radius)
normalization_value$normalization_value[a] <- nose_eye_normalization(auto_data)
normalization_value$videofile[a] <- list_of_files[a]
}
results_I <- list(radius_all, normalization_value)
results <- left_join(results_I[[1]], results_I[[2]], by = "videofile")
results$norm_radius <- as.numeric(results$radius)/results$normalization_value
return(results)
}
results <- from_DLC_to_circle(path = path, list_of_files = list_of_files)
#path <- choose.dir()
# path <- getwd()
path <- "Toolkit/module_circleestimation/"
paste0(path, "data/")
list_of_files <- list.files(path = paste0(path, "data/"), pattern = pattern)
list_of_files
#path <- choose.dir()
# path <- getwd()
path <- "Toolkit/module_circleestimation/data"
path_output <- "Toolkit/module_circleestimation/results"
pattern <- "csv"
list_of_files <- list.files(path = path, pattern = pattern)
threshold <- 0.6
data_prep_radius_estim_DLC <- function(data){
# data: data to process, a dataframe
############
# 00: load packages ----
if (!require(install.load)) {
install.packages("install.load")
}
library(install.load)
install_load("tidyverse")
# 01: functionality ----
## 01a : sub-function circle_format ----
# sub-function to transform already pre-processed datasheet into format
# necessary for circle estimation, which needs x and y for all points in two
# columns, 1 point combination per row
circle_format <- function(df_sub){
df_all <- data.frame()
df <- data.frame(matrix(ncol = 4, nrow = 0))
x <- c("x", "y", "likelihood", "frame")
colnames(df) <- x
for (frame in 1:nrow(df_sub)){
for (b in 1:5){
end_col <- b*3
start_col <- end_col - 2
df[b, 1:3] <-  df_sub[frame, start_col:end_col]
df[b, 4] <- frame
}
df_all <- rbind(df_all, df)
}
return(df_all)
}
## 01b: main ----
# list of columns needed for circle estimation used later in function
list_airsac_points <- c('Start_outline_outer_left_x','Start_outline_outer_left_y', 'Start_outline_outer_left_likelihood',
'Start_outline_outer_right_x', 'Start_outline_outer_right_y', 'Start_outline_outer_right_likelihood',
'LowestPoint_outline_x', 'LowestPoint_outline_y', 'LowestPoint_outline_likelihood',
'MidLowleft_outline_x', 'MidLowleft_outline_y', 'MidLowleft_outline_likelihood',
'MidLowright_outline_x', 'MidLowright_outline_y', 'MidLowright_outline_likelihood')
colnames <- c()
colnames[1] <- "frames"
for (x in 2: ncol(data)){
colnames[x] <- paste(data[1,x],data[2,x], sep = '_')
}
colnames(data) <- colnames
df_all <- data[-1:-2,]
df_sub <- df_all %>%
select(all_of(list_airsac_points))
df_sub <- as.data.frame(apply(df_sub,2,as.numeric))
circle_format_data <- circle_format(df_sub)
return(circle_format_data)
}
nose_eye_normalization <- function(auto_data, a = a,  min_frames = 2, threshold_normalization = 0.8){
norm_data <- c()
list_normalization_points <- c('Nose_x','Nose_y', 'Nose_likelihood',
'EyeBridge_x', 'EyeBridge_y', 'EyeBridge_likelihood')
colnames <- c()
colnames[1] <- "frames"
for (x in 2: ncol(auto_data)){
colnames[x] <- paste(auto_data[1,x],auto_data[2,x], sep = '_')
}
colnames(auto_data) <- colnames
df <- auto_data[-1:-2,]
df_sub <- df %>%
select(all_of(list_normalization_points))
df_sub <- as.data.frame(apply(df_sub,2,as.numeric))
euc_dist <- function(xbridge, xnose, ybridge, ynose){
return(sqrt(((xbridge-xnose)^2+((ybridge-ynose)^2))))
}
df_sub_normalization <- df_sub %>%
dplyr::filter(Nose_likelihood >= threshold_normalization &&
EyeBridge_likelihood >= threshold_normalization)
if(nrow(df_sub_normalization) >= min_frames){
distance <- foreach::foreach(i= 1:nrow(df_sub_normalization), .combine = c) %do%
euc_dist(df_sub_normalization$EyeBridge_x, df_sub_normalization$Nose_x,
df_sub_normalization$EyeBridge_y, df_sub_normalization$Nose_y)
} else {
distance <- NA
}
norm_data <- mean(distance, na.rm = TRUE)
return(norm_data)
}
from_DLC_to_circle <- function(path, list_of_files){
radius_all <- data.frame(matrix(ncol = 5, nrow = 0))
z <- c("radius","x","y", "frame", "videofile")
colnames(radius_all) <- z
normalization_value <- data.frame(matrix(ncol = 2, nrow = length(list_of_files)))
y <- c("normalization_value", "videofile")
colnames(normalization_value) <- y
## starting main loop ----
for (a in 1:length(list_of_files)) {
radius <- data.frame()
auto_data <- read_delim(paste(path, list_of_files[a], sep = "\\"), delim = "," )
# 02: pre-processing data ----
data_circle_estimation <- data_prep_radius_estim_DLC(data = auto_data)
grouped_data_circle_estimation <- data_circle_estimation %>%
dplyr::filter(likelihood > threshold) %>%
group_split(frame)
for(n in 1:length(grouped_data_circle_estimation)){
if (length(grouped_data_circle_estimation) > 0){
frame_data <- as.data.frame(grouped_data_circle_estimation[[n]])
if(nrow(frame_data)>=3){
circles_LAN <- CircleFitByLandau(frame_data[,1:2], ParIni = NA, epsilon = 1e-06, IterMAX = 500)
}else {
circles_LAN <- c(NA, NA, NA, NA, NA)
}
circles_res <- c(circles_LAN[3],circles_LAN[1], circles_LAN[2], n, list_of_files[a])
radius <- rbind(radius, circles_res)
colnames(radius) <- z
} else {circles_LAN <- c(NA, NA, NA, NA, NA)
circles_res <- c(circles_LAN[3],circles_LAN[1], circles_LAN[2], n, list_of_files[a])
radius <- rbind(radius, circles_res)
colnames(radius) <- z}
}
print(a)
radius_all <- rbind(radius_all, radius)
normalization_value$normalization_value[a] <- nose_eye_normalization(auto_data)
normalization_value$videofile[a] <- list_of_files[a]
}
results_I <- list(radius_all, normalization_value)
results <- left_join(results_I[[1]], results_I[[2]], by = "videofile")
results$norm_radius <- as.numeric(results$radius)/results$normalization_value
return(results)
}
results <- from_DLC_to_circle(path = path, list_of_files = list_of_files)
saveRDS(results, file = paste0(path_output, "/", savename, ".rds"))
savename <- "test"
saveRDS(results, file = paste0(path_output, "/", savename, ".rds"))
write.table(results, paste0(path_output, '/', savename, '_DLCtoRadii.csv'), row.names = FALSE, sep = ",")
rm(list=ls())
library(install.load)
install_load("tidyverse","conicfit", "scales", "spiro", "signal", "foreach")
library("foreach")
savename <- ""
path <- "Toolkit/module_circleestimation/data"
path_output <- "Toolkit/module_circleestimation/results"
pattern <- "csv"
list_of_files <- list.files(path = path, pattern = pattern)
threshold <- 0.6
data_prep_radius_estim_DLC <- function(data){
# data: data to process, a dataframe
############
# 00: load packages ----
if (!require(install.load)) {
install.packages("install.load")
}
library(install.load)
install_load("tidyverse")
# 01: functionality ----
## 01a : sub-function circle_format ----
# sub-function to transform already pre-processed datasheet into format
# necessary for circle estimation, which needs x and y for all points in two
# columns, 1 point combination per row
circle_format <- function(df_sub){
df_all <- data.frame()
df <- data.frame(matrix(ncol = 4, nrow = 0))
x <- c("x", "y", "likelihood", "frame")
colnames(df) <- x
for (frame in 1:nrow(df_sub)){
for (b in 1:5){
end_col <- b*3
start_col <- end_col - 2
df[b, 1:3] <-  df_sub[frame, start_col:end_col]
df[b, 4] <- frame
}
df_all <- rbind(df_all, df)
}
return(df_all)
}
## 01b: main ----
# list of columns needed for circle estimation used later in function
list_airsac_points <- c('Start_outline_outer_left_x','Start_outline_outer_left_y', 'Start_outline_outer_left_likelihood',
'Start_outline_outer_right_x', 'Start_outline_outer_right_y', 'Start_outline_outer_right_likelihood',
'LowestPoint_outline_x', 'LowestPoint_outline_y', 'LowestPoint_outline_likelihood',
'MidLowleft_outline_x', 'MidLowleft_outline_y', 'MidLowleft_outline_likelihood',
'MidLowright_outline_x', 'MidLowright_outline_y', 'MidLowright_outline_likelihood')
colnames <- c()
colnames[1] <- "frames"
for (x in 2: ncol(data)){
colnames[x] <- paste(data[1,x],data[2,x], sep = '_')
}
colnames(data) <- colnames
df_all <- data[-1:-2,]
df_sub <- df_all %>%
select(all_of(list_airsac_points))
df_sub <- as.data.frame(apply(df_sub,2,as.numeric))
circle_format_data <- circle_format(df_sub)
return(circle_format_data)
}
nose_eye_normalization <- function(auto_data, a = a,  min_frames = 2, threshold_normalization = 0.8){
norm_data <- c()
list_normalization_points <- c('Nose_x','Nose_y', 'Nose_likelihood',
'EyeBridge_x', 'EyeBridge_y', 'EyeBridge_likelihood')
colnames <- c()
colnames[1] <- "frames"
for (x in 2: ncol(auto_data)){
colnames[x] <- paste(auto_data[1,x],auto_data[2,x], sep = '_')
}
colnames(auto_data) <- colnames
df <- auto_data[-1:-2,]
df_sub <- df %>%
select(all_of(list_normalization_points))
df_sub <- as.data.frame(apply(df_sub,2,as.numeric))
euc_dist <- function(xbridge, xnose, ybridge, ynose){
return(sqrt(((xbridge-xnose)^2+((ybridge-ynose)^2))))
}
df_sub_normalization <- df_sub %>%
dplyr::filter(Nose_likelihood >= threshold_normalization &&
EyeBridge_likelihood >= threshold_normalization)
if(nrow(df_sub_normalization) >= min_frames){
distance <- foreach::foreach(i= 1:nrow(df_sub_normalization), .combine = c) %do%
euc_dist(df_sub_normalization$EyeBridge_x, df_sub_normalization$Nose_x,
df_sub_normalization$EyeBridge_y, df_sub_normalization$Nose_y)
} else {
distance <- NA
}
norm_data <- mean(distance, na.rm = TRUE)
return(norm_data)
}
from_DLC_to_circle <- function(path, list_of_files){
radius_all <- data.frame(matrix(ncol = 5, nrow = 0))
z <- c("radius","x","y", "frame", "videofile")
colnames(radius_all) <- z
normalization_value <- data.frame(matrix(ncol = 2, nrow = length(list_of_files)))
y <- c("normalization_value", "videofile")
colnames(normalization_value) <- y
## starting main loop ----
for (a in 1:length(list_of_files)) {
radius <- data.frame()
auto_data <- read_delim(paste(path, list_of_files[a], sep = "\\"), delim = "," )
# 02: pre-processing data ----
data_circle_estimation <- data_prep_radius_estim_DLC(data = auto_data)
grouped_data_circle_estimation <- data_circle_estimation %>%
dplyr::filter(likelihood > threshold) %>%
group_split(frame)
for(n in 1:length(grouped_data_circle_estimation)){
if (length(grouped_data_circle_estimation) > 0){
frame_data <- as.data.frame(grouped_data_circle_estimation[[n]])
if(nrow(frame_data)>=3){
circles_LAN <- CircleFitByLandau(frame_data[,1:2], ParIni = NA, epsilon = 1e-06, IterMAX = 500)
}else {
circles_LAN <- c(NA, NA, NA, NA, NA)
}
circles_res <- c(circles_LAN[3],circles_LAN[1], circles_LAN[2], n, list_of_files[a])
radius <- rbind(radius, circles_res)
colnames(radius) <- z
} else {circles_LAN <- c(NA, NA, NA, NA, NA)
circles_res <- c(circles_LAN[3],circles_LAN[1], circles_LAN[2], n, list_of_files[a])
radius <- rbind(radius, circles_res)
colnames(radius) <- z}
}
print(a)
radius_all <- rbind(radius_all, radius)
normalization_value$normalization_value[a] <- nose_eye_normalization(auto_data)
normalization_value$videofile[a] <- list_of_files[a]
}
results_I <- list(radius_all, normalization_value)
results <- left_join(results_I[[1]], results_I[[2]], by = "videofile")
results$norm_radius <- as.numeric(results$radius)/results$normalization_value
return(results)
}
results <- from_DLC_to_circle(path = path, list_of_files = list_of_files)
write.table(results, paste0(path_output, '/', savename, '_DLCtoRadii.csv'), row.names = FALSE, sep = ",")
saveRDS(results, file = paste0(path_output, "/", savename, "_DLCtoRadii.rds"))
`_DLCtoRadii` <- readRDS("D:/PostDoc/Donders/AirSacTracker_2/AirSacTracker/Toolkit/module_circleestimation/results/_DLCtoRadii.rds")
View(`_DLCtoRadii`)
library(readr)
X_DLCtoRadii <- read_csv("Toolkit/module_circleestimation/results/_DLCtoRadii.csv")
View(X_DLCtoRadii)
library(install.load)
install_load("tidyverse","conicfit", "scales", "spiro", "signal", "foreach", "Hmisc", "cowplot", "corrplot", "rstatix", "ggcorrplot")
# path in Github structure: \AirSacTracker\Project\Proof_of_concept_analyses2
acoustics_bark <- readRDS("acoustics_bark_multi_checked_proof_2.rds")
filename <- as.data.frame(matrix(unlist(filename),ncol=2,byrow=T))
radius_boom_bark_sequences$match <- filename[,1]
radius_boom_bark_sequences_last <- radius_boom_bark_sequences %>%
group_split(videofile)
data_last <- c()
for(z in 1:length(radius_boom_bark_sequences_last)){
data <- radius_boom_bark_sequences_last[[z]]
data <- data %>%
mutate(radius = as.numeric(radius),
frame = as.numeric(frame))
data <- data[!is.na(data$radius),]
if(nrow(data) > 1){
last_data <- data[data$frame == max(data$frame),]
data_last <- rbind(data_last, last_data)
} else {
last_data <- NA
data_last <- rbind(data_last, last_data)
}
}
# path in Github structure: \AirSacTracker\Project\Proof_of_concept_analyses2
radius_boom_bark_sequences <- readRDS("circle_estimation_boom_DLC_proof2.rds")
# path in Github structure: \AirSacTracker\Project\Proof_of_concept_analyses2
acoustics_bark <- readRDS("\Project\Proof_of_concept_analyses2\acoustics_bark_multi_checked_proof_2.rds")
# path in Github structure: \AirSacTracker\Project\Proof_of_concept_analyses2
radius_boom_bark_sequences <- readRDS("/Project/Proof_of_concept_analyses2/circle_estimation_boom_DLC_proof2.rds")
# path in Github structure: \AirSacTracker\Project\Proof_of_concept_analyses2
acoustics_bark <- readRDS("Project/Proof_of_concept_analyses2/acoustics_bark_multi_checked_proof_2.rds")
# path in Github structure: \AirSacTracker\Project\Proof_of_concept_analyses2
radius_boom_bark_sequences <- readRDS("Project/Proof_of_concept_analyses2/circle_estimation_boom_DLC_proof2.rds")
### video match name
filename <- strsplit(radius_boom_bark_sequences$videofile, split  = "boomDLC")
filename <- as.data.frame(matrix(unlist(filename),ncol=2,byrow=T))
radius_boom_bark_sequences$match <- filename[,1]
radius_boom_bark_sequences_last <- radius_boom_bark_sequences %>%
group_split(videofile)
data_last <- c()
for(z in 1:length(radius_boom_bark_sequences_last)){
data <- radius_boom_bark_sequences_last[[z]]
data <- data %>%
mutate(radius = as.numeric(radius),
frame = as.numeric(frame))
data <- data[!is.na(data$radius),]
if(nrow(data) > 1){
last_data <- data[data$frame == max(data$frame),]
data_last <- rbind(data_last, last_data)
} else {
last_data <- NA
data_last <- rbind(data_last, last_data)
}
}
radius_boom_bark_sequences_max <- radius_boom_bark_sequences %>%
group_split(videofile)
data_max <- c()
for(z in 1:length(radius_boom_bark_sequences_max)){
data <- radius_boom_bark_sequences_last[[z]]
data <- data %>%
mutate(radius = as.numeric(radius),
frame = as.numeric(frame))
data <- data[!is.na(data$radius),]
if(nrow(data) > 1){
max_data <- data[data$radius == max(data$radius, na.rm = TRUE),]
data_max <- rbind (data_max, max_data)
} else {
max_data <- NA
data_max <- rbind(data_max,max_data)
}
}
acoustic_bark_summary <- acoustics_bark %>%
group_by(audiofile) %>%
summarise(across(c("ampl", "specCentroid", "dom", "entropy", "entropySh", "f1_freq", "f2_freq", "specSlope", "pitch", "harmEnergy",
"peakFreq", "HNR"),
list(mean = mean, min = min, max = max, median = median), na.rm = TRUE))
filename <- strsplit(acoustic_bark_summary$audiofile, split  = "bark")
filename <- as.data.frame(matrix(unlist(filename),ncol=2,byrow=T))
filename <- strsplit(filename$V1, split  = "multisource")
filename <- as.data.frame(matrix(unlist(filename),ncol=2,byrow=T))
acoustic_bark_summary$match <- filename[,2]
combined_radius_acoustics_boom_bark_max <- left_join(data_max, acoustic_bark_summary)
combined_radius_acoustics_boom_bark_last <- left_join(data_last, acoustic_bark_summary)
acoustic_correlation_max <- combined_radius_acoustics_boom_bark_max %>%
dplyr::filter(radius < 350) %>%
select(radius, ampl_mean, pitch_mean, entropy_mean, specCentroid_mean, f1_freq_mean, f2_freq_mean,
peakFreq_mean,
ampl_max, pitch_max, entropy_max, specCentroid_max, f1_freq_max, f2_freq_max,
peakFreq_max,
ampl_min, pitch_min, entropy_min, specCentroid_min, f1_freq_min, f2_freq_min,
peakFreq_min,
ampl_median, pitch_median, entropy_median, specCentroid_median, f1_freq_median, f2_freq_median,
peakFreq_median)
acoustic_correlation_last <- combined_radius_acoustics_boom_bark_last %>%
select(radius, ampl_mean, pitch_mean, entropy_mean, specCentroid_mean, f1_freq_mean, f2_freq_mean,
peakFreq_mean,
ampl_max, pitch_max, entropy_max, specCentroid_max, f1_freq_max, f2_freq_max,
peakFreq_max,
ampl_min, pitch_min, entropy_min, specCentroid_min, f1_freq_min, f2_freq_min,
peakFreq_min)#,
# #corrplots with ggcorrplot: http://www.sthda.com/english/wiki/ggcorrplot-visualization-of-a-correlation-matrix-using-ggplot2
corr_last <- as.data.frame(round(cor(acoustic_correlation_last, use = "pairwise.complete.obs", method = "pearson"),1))
corr_last_sub <- corr_last %>%
dplyr::filter(radius != 1) %>% # to filter out radius v radius, as we can't do that in the ggcorrplot function
select("radius")
row.names(corr_last_sub) <- c("Amplitude mean", "F0 mean", "Entropy mean", "Spectral Centroid mean",
"F1 mean", "F2 mean", "Peak Frequency mean", "Amplitude max", "F0 max",
"Entropy max", "Spectral Centroid max",
"F1 max", "F2 max", "peak Frequency max ","Amplitude min", "F0 min", "Entropy min", "Spectral Centroid min",
"F1 min", "F2 min", "peak Frequency min")
colnames(corr_last_sub) <- c("Radius")
p.mat_last <- cor_pmat(corr_last)
view(p.mat_last)
1.413903e-01
